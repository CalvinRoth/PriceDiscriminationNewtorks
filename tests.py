from helperFun import *
import numpy as np
import matplotlib.pyplot as plt


# Histogram of graphs generated by the same n and p
def sameparamProfitsTest(n: int, p: float, steps, rho, a, c):
    results = np.zeros(steps)
    for i in range(steps):
        A, G = makeERGraph(n, p)
        results[i] = profitDiscrim(A, n, p, a, c, rho)
    return results


# Histogram of graphs generated that have the same degree sequence
def sameseqProfitsTest(n, p, steps, rho, a, c):
    results = np.zeros(steps)
    A, G = makeERGraph(n, p)
    for i in range(steps):
        B = makeSimilarGraph(G)
        results[i] = profitDiscrim(B, n, p, a, c, rho)
    return results


def ProfitsTest(n, p, steps, rho, a, c):
    sameSeqRes = sameseqProfitsTest(n, p, steps, rho, a, c)
    sameParRes = sameparamProfitsTest(n, p, steps, rho, a, c)
    return sameSeqRes, sameParRes


# How does the variance of optimal profit vary as a function of p
def sameseqProfitsVarTest(n, p_range, steps, rho, a, c):
    iters = len(p_range)
    results = np.zeros(iters)
    for i in range(iters):
        res = sameseqProfitsTest(n, p_range[i], steps, rho, a, c)
        results[i] = np.var(res)
    return results


# How does the variance of optimal profit vary as a function of p
def sameparamProfitsVarTest(n, p_range, steps, rho, a, c):
    iters = len(p_range)
    results = np.zeros(iters)
    for i in range(iters):
        res = sameparamProfitsTest(n, p_range[i], steps, rho, a, c)
        results[i] = np.var(res)
    return results


def sameseqcomparePrices(n: int, p: float, steps: int, rho, a, c):
    A, G = makeERGraph(n, p)
    results = np.zeros((n, steps))
    for i in range(steps):
        B = makeSimilarGraph(G)
        v = priceVector(B, rho, a, c)
        v.resize((n,))
        results[:, i] = v
    return results


# likewise but for same distribution
def sameparamcomparePrices(n: int, p: float, steps: int, rho, a, c):
    results = np.zeros((n, steps))
    for i in range(steps):
        A, G = makeERGraph(n, p)
        v = priceVector(A, rho, a, c)
        v.resize((n,))
        results[:, i] = v
    return results


# Generates one true graph and looks at the effect of trying to get information from different number of
# guessed graphs can do. Creates graph and returns vector of results
def nTrialstest(n, p, n_trials_list, rho, a, c):
    A, G = makeERGraph(n, p)
    true_profit = np.real(applyPriceVector(A, priceVector(A, rho, a, c), rho, a, c))
    # the average vector initilized with sample size of 1
    results = np.zeros(len(n_trials_list))
    for (i, trial_size) in enumerate(n_trials_list):

        averageV = priceVector(makeSimilarGraph(G), rho, a, c)
        # And another n_trials-1 trials
        for j in range(trial_size - 1):
            averageV += priceVector(makeSimilarGraph(G), rho, a, c)
        averageV /= trial_size  # Scaling
        profit = np.real(applyPriceVector(A, averageV, rho, a, c))
        results[i] = true_profit / profit

    figure = plt.figure()
    ax1 = figure.add_axes((0.1, 0.2, 0.8, 0.7))
    ax1.plot(n_trials_list, results)
    ax1.set_xlabel("n_trials")
    ax1.set_ylabel("Fraction")
    ax1.set_title("N_trials vs fractional gap")
    txt = F"Figure for fractional gap as we change the number of trials used as an average price\\ vector.\
     Parameters are n:{n}, p=1.3/n, a={4},c={2}, rho={0.9}"
    figure.text(0.5, 0.05, txt, ha="center")
    plt.show()
    return results


def fractionalRegretOVerP(n, p0, p1, steps, n_trials, rho, a, c):
    results_seq = np.zeros(steps)
    results_param = np.zeros(steps)
    delta = (p1 - p0) / steps
    Ps = [p0 + (i * delta) for i in range(steps)]
    for i, p in enumerate(Ps):
        A_true, G_true = makeERGraph(n, p)
        seqScore = 0
        parScore = 0
        v = np.zeros((n,1))
        for j in range(n_trials):
            A_seq = makeSimilarGraph(G_true)  # for same seq
            A_par, B = makeERGraph(n, p)  # Same Param
            v_seq = priceVector(A_seq, rho, a, c)
            v_par = priceVector(A_par, rho, a, c)
            parScore += fractionalRegret(A_true, v_par, n, p, rho, a, c)
            seqScore += fractionalRegret(A_true, v_seq, n,p, rho, a,c)
        parScore /= n_trials
        seqScore /= n_trials
        results_seq[i] = seqScore
        results_param[i] = parScore
    return results_seq, results_param


def sanityCheck(n,p,rho, a,c):
    A,G = makeERGraph(n,p)
    prof = profitDiscrim(A,n,p,a,c,rho)
    v = priceVector(A,rho, a,c)
    check = applyPriceVector(A,v,rho, a, c)
    return prof, check